// Simplified version without BullMQ/Redis for testing
import { EventEmitter } from 'events';
import { randomUUID } from 'crypto';
import { v4 as uuidv4 } from 'uuid';
import * as fs from 'fs';
import * as path from 'path';

// Single instance of job storage
let jobs: ConversionJob[] = [];
const completedJobs: Map<string, JobStatus> = new Map();
const jobProgress: Map<string, number> = new Map();
const subscribers = new Map<string, Set<(data: any) => void>>();
const jobEvents = new EventEmitter();

// For debugging
console.log('Queue manager initialized. Current jobs:', jobs.length);

// Create the persistent storage files
const DATA_DIR = path.join(process.cwd(), 'data');
const COMPLETED_JOBS_FILE = path.join(DATA_DIR, 'completed-jobs.json');
const JOBS_FILE = path.join(DATA_DIR, 'jobs.json');

// Ensure data directory exists
if (!fs.existsSync(DATA_DIR)) {
  fs.mkdirSync(DATA_DIR, { recursive: true });
}

// Load completed jobs from disk
function loadCompletedJobsFromDisk() {
  try {
    if (fs.existsSync(COMPLETED_JOBS_FILE)) {
      const data = fs.readFileSync(COMPLETED_JOBS_FILE, 'utf8');
      const jobsObj = JSON.parse(data);
      const loadedJobs = new Map<string, JobStatus>();
      
      Object.entries(jobsObj).forEach(([key, value]) => {
        loadedJobs.set(key, value as JobStatus);
      });
      
      console.log(`Loaded ${loadedJobs.size} completed jobs from disk`);
      return loadedJobs;
    }
  } catch (error) {
    console.error('Error loading completed jobs from disk:', error);
  }
  return new Map<string, JobStatus>();
}

// Save completed jobs to disk
function saveCompletedJobsToDisk() {
  try {
    const jobsObj = Object.fromEntries(completedJobs);
    fs.writeFileSync(COMPLETED_JOBS_FILE, JSON.stringify(jobsObj, null, 2));
    console.log(`Saved ${completedJobs.size} completed jobs to disk`);
  } catch (error) {
    console.error('Error saving completed jobs to disk:', error);
  }
}

// Load jobs from disk
function loadJobsFromDisk() {
  try {
    if (fs.existsSync(JOBS_FILE)) {
      const data = fs.readFileSync(JOBS_FILE, 'utf8');
      const jobsObj = JSON.parse(data);
      return jobsObj as ConversionJob[];
    }
  } catch (error) {
    console.error('Error loading jobs from disk:', error);
  }
  return [];
}

// Save jobs to disk
function saveJobsToDisk() {
  try {
    const jobsObj = jobs;
    fs.writeFileSync(JOBS_FILE, JSON.stringify(jobsObj, null, 2));
    console.log(`Saved ${jobs.length} jobs to disk`);
  } catch (error) {
    console.error('Error saving jobs to disk:', error);
  }
}

// Initialize with data from disk
jobs = loadJobsFromDisk();
const loadedCompletedJobs = loadCompletedJobsFromDisk();
completedJobs.forEach((value, key) => loadedCompletedJobs.set(key, value));
completedJobs.clear();
loadedCompletedJobs.forEach((value, key) => completedJobs.set(key, value));

// Job types
export interface ConversionJob {
  jobId: string;
  userId: string;
  files: Array<{
    name: string;
    size: number;
    type: string;
    path: string;
    convertedPath?: string;
    thumbnailUrl?: string;
    convertedName?: string;
    status?: 'processing' | 'completed' | 'failed';
  }>;
  outputFormat: string;
  quality: number;
  pdfOptions?: {
    pageSize: string;
    orientation: string;
  };
  status?: 'processing' | 'completed' | 'failed';
  progress?: number;
  createdAt?: Date;
  completedAt?: Date;
  error?: string;
  zipUrl?: string;
  combinedPdfUrl?: string;
}

interface JobStatus {
  jobId: string;
  userId: string;
  files: Array<{
    name: string;
    size: number;
    type: string;
    path: string;
    convertedPath?: string;
    thumbnailUrl?: string;
    convertedName?: string;
    status?: 'processing' | 'completed' | 'failed';
  }>;
  outputFormat: string;
  status: 'processing' | 'completed' | 'failed';
  completedAt?: Date;
  error?: string;
  progress?: number;
  zipUrl?: string;
  combinedPdfUrl?: string;
}

// Add a new conversion job
export async function addJob(jobData: any): Promise<string> {
  const jobId = jobData.jobId || uuidv4();
  const job: ConversionJob = {
    jobId,
    ...jobData,
    status: 'pending',
    progress: 0,
    createdAt: new Date()
  };
  
  // Store job in memory
  jobs.push(job);
  console.log(`Queue manager - Added job ${jobId}. Total jobs:`, jobs.length);
  saveJobsToDisk();
  
  // For testing purposes, immediately process the job
  setTimeout(() => processJob(job), 500);
  
  return jobId;
}

// Process a job (simulated)
async function processJob(job: ConversionJob): Promise<void> {
  console.log('=== Starting job processing for job ID:', job.jobId);
  console.log('Processing job', job.jobId, 'with', job.files.length, 'files');
  console.log('Job details:', {
    jobId: job.jobId,
    userId: job.userId,
    files: job.files,
    outputFormat: job.outputFormat,
    quality: job.quality
  });

  try {
    // Update job status to processing
    job.status = 'processing';
    job.progress = 0;
    notifyJobUpdate(job);
    
    // Clear module cache to ensure we get the latest version
    delete require.cache[require.resolve('../conversion/heic-converter')];
    
    // Import the converter
    const { processHeicConversion } = require('../conversion/heic-converter');
    
    // Process the files with the job ID
    const conversionResult = await processHeicConversion(
      job.files,
      job.outputFormat,
      job.quality,
      job.pdfOptions || { pageSize: 'a4', orientation: 'portrait' },
      (progress) => {
        job.progress = progress.percentage;
        notifyJobUpdate(job);
        return Promise.resolve();
      },
      job.jobId  // Pass the job ID to the converter
    );
    
    // Update job status to completed
    job.status = 'completed';
    job.progress = 100;
    job.completedAt = new Date();
    
    // Update file paths in job status
    job.files = job.files.map((file, index) => ({
      ...file,
      convertedPath: conversionResult.files[index].url,
      thumbnailUrl: conversionResult.files[index].thumbnailUrl,
      convertedName: conversionResult.files[index].convertedName,
      status: 'completed'
    }));
    
    // Save to completed jobs
    completedJobs.set(job.jobId, {
      jobId: job.jobId,
      userId: job.userId,
      files: job.files,
      outputFormat: job.outputFormat,
      status: 'completed',
      completedAt: job.completedAt
    });
    saveCompletedJobsToDisk();
    
    // Remove from queue
    jobs = jobs.filter(j => j.jobId !== job.jobId);
    saveJobsToDisk();
    
    // Notify subscribers
    notifyJobUpdate(job);
  } catch (error: any) {
    console.error('Error during HEIC conversion:', error);
    
    const failedJob: JobStatus = {
      jobId: job.jobId,
      userId: job.userId,
      files: job.files,
      outputFormat: job.outputFormat,
      status: 'failed',
      error: error instanceof Error ? error.message : 'Conversion failed'
    };
    
    console.error('Job failed:', failedJob);
    completedJobs.set(job.jobId, failedJob); // Save failed jobs too
    saveCompletedJobsToDisk(); // Save to disk
    
    // Remove from queue
    jobs = jobs.filter(j => j.jobId !== job.jobId);
    saveJobsToDisk(); // Save to disk
    
    // Notify subscribers
    notifyJobUpdate(job);
  }
}

// Utility function to generate a simple gradient JPEG
function generateGradientJpeg() {
  // This is a simple blue gradient JPEG for testing
  // In a real application, this would be replaced with actual conversion results
  const jpegData = Buffer.from([
    0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48, 
    0x00, 0x48, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 
    0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0a, 0x0c, 0x14, 0x0d, 0x0c, 0x0b, 0x0b, 0x0c, 0x19, 0x12, 
    0x13, 0x0f, 0x14, 0x1d, 0x1a, 0x1f, 0x1e, 0x1d, 0x1a, 0x1c, 0x1c, 0x20, 0x24, 0x2e, 0x27, 0x20, 
    0x22, 0x2c, 0x23, 0x1c, 0x1c, 0x28, 0x37, 0x29, 0x2c, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1f, 0x27, 
    0x39, 0x3d, 0x38, 0x32, 0x3c, 0x2e, 0x33, 0x34, 0x32, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x09, 0x09, 
    0x09, 0x0c, 0x0b, 0x0c, 0x18, 0x0d, 0x0d, 0x18, 0x32, 0x21, 0x1c, 0x21, 0x32, 0x32, 0x32, 0x32, 
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0xff, 0xc0, 
    0x00, 0x11, 0x08, 0x00, 0x64, 0x00, 0x64, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 
    0x01, 0xff, 0xc4, 0x00, 0x1f, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 
    0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 
    0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 
    0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 
    0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 
    0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 
    0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 
    0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 
    0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 
    0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 
    0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xff, 0xc4, 0x00, 0x1f, 0x01, 0x00, 0x03, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x11, 0x00, 
    0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 
    0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 
    0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 
    0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 
    0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 
    0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 
    0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 
    0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 
    0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 
    0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 
    0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 
    0xfa, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xe3, 
    0xf4, 0xef, 0x0a, 0xea, 0xda, 0xbd, 0xd8, 0xb7, 0xd3, 0xec, 0xee, 0x2e, 0xa5, 0x27, 0x00, 0x46, 
    0x85, 0xbf, 0x5e, 0x95, 0xdf, 0x5a, 0xfc, 0x01, 0xf1, 0x9d, 0xe5, 0xa7, 0x9f, 0x6f, 0xe1, 0x1d, 
    0x52, 0x48, 0xb2, 0x54, 0x91, 0x01, 0x20, 0x91, 0x82, 0x38, 0xef, 0x56, 0x3e, 0x02, 0xdd, 0x47, 
    0x17, 0x8d, 0x67, 0x49, 0x18, 0x57, 0x68, 0x18, 0x2a, 0x9e, 0x4e, 0x09, 0x15, 0xeb, 0x51, 0xf8, 
    0x36, 0xf6, 0x3f, 0x16, 0x37, 0x88, 0x24, 0xd4, 0x6d, 0x64, 0x21, 0x98, 0xbc, 0x2b, 0x0e, 0x63, 
    0x8c, 0x8c, 0x67, 0x9e, 0xbc, 0x0c, 0x77, 0xaf, 0x13, 0x19, 0x89, 0xad, 0x09, 0x20, 0xff, 0x00, 
    0xd0, 0x19, 0x7b, 0xfe, 0x78, 0xff, 0x00, 0x33, 0x48, 0xeb, 0xf8, 0x64, 0xed, 0xfd, 0xff, 0x00, 
    0x89, 0xb8, 0xa5, 0xef, 0xfc, 0xf3, 0xfd, 0x69, 0x75, 0xa0, 0xff, 0x00, 0xd6, 0x38, 0xc9, 0xa5, 
    0xc1, 0xfe, 0xad, 0xbe, 0xa2, 0xad, 0x8c, 0x41, 0xaf, 0x65, 0xcc, 0x55, 0xed, 0xc3, 0xf8, 0x4f, 
    0x2d, 0xe4, 0xf7, 0x16, 0xde, 0x74, 0x52, 0x3a, 0x3a, 0x30, 0xc1, 0x56, 0x52, 0x08, 0x23, 0xdc, 
    0x11, 0x54, 0xdc, 0x9c, 0xf3, 0xd6, 0xbd, 0x13, 0xe2, 0xc6, 0x9e, 0x90, 0xf8, 0xaa, 0x4b, 0x81, 
    0x18, 0x57, 0xbc, 0x45, 0x95, 0x82, 0x8c, 0x06, 0x23, 0x82, 0x7d, 0xc9, 0x15, 0xe7, 0xc3, 0x9f, 
    0xf3, 0x8a, 0xf6, 0x28, 0xd4, 0xe7, 0x82, 0x67, 0xea, 0x7c, 0x37, 0x9a, 0x2c, 0xc3, 0x29, 0xa5, 
    0x57, 0xbd, 0xad, 0xf2, 0x7a, 0x7e, 0x3b, 0x88, 0x4d, 0x01, 0x34, 0xa2, 0x90, 0xd6, 0xa7, 0xb0, 
    0x7f, 0xff, 0xd9
  ]);
  return jpegData;
}

// Get job status
export async function getJobStatus(jobId: string): Promise<JobStatus | null> {
  console.log('=== Queue manager - Getting job status ===');
  console.log('Job ID:', jobId);
  console.log('Current jobs:', jobs);
  
  // First check active jobs
  const job = jobs.find(j => j.jobId === jobId);
  if (job) {
    return {
      jobId: job.jobId,
      userId: job.userId,
      files: job.files,
      outputFormat: job.outputFormat,
      status: 'processing',
      progress: jobProgress.get(jobId) || 0
    };
  }
  
  // If not in active jobs, check completed jobs
  const completedJob = completedJobs.get(jobId);
  if (completedJob) {
    console.log(`Found completed job: ${jobId}`, completedJob);
    return completedJob;
  }
  
  console.log(`Job ${jobId} not found in queue or completed jobs. Available jobs:`, jobs);
  return null;
}

// Subscribe to job progress updates
export function subscribeToJobProgress(jobId: string, callback: (data: any) => void): () => void {
  if (!subscribers.has(jobId)) {
    subscribers.set(jobId, new Set());
  }
  
  const jobSubscribers = subscribers.get(jobId)!;
  jobSubscribers.add(callback);
  
  // Return unsubscribe function
  return () => {
    const subs = subscribers.get(jobId);
    if (subs) {
      subs.delete(callback);
      if (subs.size === 0) {
        subscribers.delete(jobId);
      }
    }
  };
}

// Notify subscribers of job updates
function notifyJobUpdate(job: any): void {
  const subs = subscribers.get(job.jobId);
  if (subs) {
    subs.forEach(callback => {
      try {
        callback(job);
      } catch (error) {
        console.error('Error in job update callback:', error);
      }
    });
  }
  
  jobEvents.emit(`job.progress.${job.jobId}`, { jobId: job.jobId, progress: jobProgress.get(job.jobId) || 0 });
}

// Get queue statistics (mock implementation)
export async function getQueueStats() {
  return {
    waiting: jobs.length,
    active: jobs.filter(job => job.status === 'processing').length,
    completed: Array.from(completedJobs.values()).filter(job => job.status === 'completed').length,
    failed: Array.from(completedJobs.values()).filter(job => job.status === 'failed').length
  };
}

// Clean up resources
export async function closeQueue() {
  // No actual connections to close in this simplified version
  return Promise.resolve();
}

// Get waiting jobs count
export async function getWaitingJobsCount() {
  return (await getQueueStats()).waiting;
}

// Get active jobs count
export async function getActiveJobsCount() {
  return (await getQueueStats()).active;
}

export async function getCompletedJobsCount() {
  return (await getQueueStats()).completed;
}

// Get failed jobs count
export async function getFailedJobsCount() {
  return (await getQueueStats()).failed;
}

// Export jobs for debugging
export { jobs };
